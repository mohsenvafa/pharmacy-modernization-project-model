# GraphQL Implementation Guide

This document describes the GraphQL implementation in the rxintake_scaffold application.

## Overview

We've implemented **Phase 1** of the GraphQL architecture: a simple, monolithic GraphQL server that reuses existing domain services. This approach provides:

- ✅ Zero network overhead (all in-process)
- ✅ Simple deployment (single binary)
- ✅ Shared middleware and error handling
- ✅ Fast development cycles
- ✅ Type-safe with code generation via gqlgen

## Architecture

```
Client
  ↓
HTTP Request → /graphql endpoint
  ↓
GraphQL Server (internal/graphql/server.go)
  ↓
Resolvers (internal/graphql/schema.resolvers.go)
  ↓
Domain Services (same as REST API)
  ↓
Repositories
  ↓
Data Layer
```

### GraphQL as a Delivery Layer

GraphQL sits alongside REST API and UI as another **delivery surface**. All three use the same business logic:

```
┌─────────────────────────────────────┐
│      Delivery Layers (Choose One)   │
├─────────────┬───────────┬───────────┤
│  REST API   │  GraphQL  │    UI     │
└──────┬──────┴─────┬─────┴─────┬─────┘
       │            │           │
       └────────────┴───────────┘
                    ↓
       ┌────────────────────────┐
       │   Domain Services      │
       │  (Business Logic)      │
       └────────────────────────┘
```

## Project Structure

```
domain/
  patient/
    ├── api/                     # REST API
    ├── graphql/                 # GraphQL API (domain-specific)
    │   ├── schema.graphql       # Patient types
    │   └── resolver.go          # Patient resolvers
    └── service/

  prescription/
    ├── api/
    ├── graphql/                 # GraphQL API (domain-specific)
    │   ├── schema.graphql       # Prescription types
    │   └── resolver.go          # Prescription resolvers
    └── service/

  dashboard/
    ├── graphql/                 # GraphQL API (domain-specific)
    │   ├── schema.graphql       # Dashboard types
    │   └── resolver.go          # Dashboard resolvers
    └── service/

internal/
  graphql/
    ├── schema.graphql           # Root schema (Query, Mutation)
    ├── server.go                # Server setup & endpoint mounting
    ├── resolver.go              # Aggregates domain resolvers
    ├── schema.resolvers.go      # Delegates to domain resolvers
    └── generated/               # Auto-generated by gqlgen
        ├── generated.go
        └── models_gen.go

gqlgen.yml                       # gqlgen configuration
```

**Note:** GraphQL is now organized by domain, just like the REST API! See `docs/GRAPHQL_DOMAIN_STRUCTURE.md` for details.

## Endpoints

Once the server is running:

- **GraphQL API**: `http://localhost:8080/graphql`
- **GraphQL Playground**: `http://localhost:8080/playground` (development UI)

**Note:** Paths are defined in `internal/platform/paths/registry.go` as constants:
- `paths.GraphQLPath` = `"/graphql"`
- `paths.GraphQLPlayground` = `"/playground"`

## Schema

The GraphQL schema mirrors the domain models closely to avoid over-engineering:

### Patient Domain

```graphql
type Patient {
  id: ID!
  name: String!
  dob: Time!
  phone: String!
  state: String!
  createdAt: Time!
  addresses: [Address!]!
  prescriptions: [Prescription!]!
}

type Address {
  id: ID!
  patientID: ID!
  line1: String!
  line2: String
  city: String!
  state: String!
  zip: String!
}
```

### Prescription Domain

```graphql
type Prescription {
  id: ID!
  patientID: ID!
  patient: Patient
  drug: String!
  dose: String!
  status: PrescriptionStatus!
  createdAt: Time!
}

enum PrescriptionStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
}
```

### Dashboard Domain

```graphql
type DashboardStats {
  totalPatients: Int!
  activePrescriptions: Int!
}
```

## Queries

### Get Single Patient

```graphql
query GetPatient {
  patient(id: "123") {
    id
    name
    phone
    addresses {
      line1
      city
      state
    }
  }
}
```

### List Patients

```graphql
query ListPatients {
  patients(query: "John", limit: 10, offset: 0) {
    id
    name
    phone
    state
  }
}
```

### Patient with Prescriptions

```graphql
query PatientWithPrescriptions {
  patient(id: "123") {
    id
    name
    prescriptions {
      id
      drug
      dose
      status
    }
  }
}
```

### Get Prescription with Patient

```graphql
query PrescriptionWithPatient {
  prescription(id: "456") {
    id
    drug
    dose
    patient {
      name
      phone
    }
  }
}
```

### List Prescriptions

```graphql
query ListPrescriptions {
  prescriptions(status: "Active", limit: 20) {
    id
    drug
    dose
    status
    patient {
      name
    }
  }
}
```

### Dashboard Stats

```graphql
query GetDashboardStats {
  dashboardStats {
    totalPatients
    activePrescriptions
  }
}
```

## Resolver Implementation

Resolvers are simple pass-throughs to domain services:

```go
// Query resolver - calls service directly
func (r *queryResolver) Patient(ctx context.Context, id string) (*model.Patient, error) {
    patient, err := r.PatientService.GetByID(ctx, id)
    if err != nil {
        r.Logger.Error("Failed to fetch patient", zap.String("patient_id", id), zap.Error(err))
        if errors.IsNotFoundError(err) {
            return nil, nil // Return null for not found
        }
        return nil, err
    }
    return &patient, nil
}

// Field resolver - resolves nested data
func (r *patientResolver) Addresses(ctx context.Context, obj *model.Patient) ([]model.Address, error) {
    return r.AddressService.GetByPatientID(ctx, obj.ID)
}
```

### Key Patterns:

1. **No business logic in resolvers** - all logic in services
2. **Error handling** - log errors, return nil for not found
3. **Reuse services** - same code as REST API
4. **Type conversion** - map domain models to GraphQL types when needed

## Adding New Fields/Queries

### 1. Update Schema

Edit `internal/graphql/schema.graphql`:

```graphql
type Patient {
  # ... existing fields
  activeOrders: Int!  # NEW
}
```

### 2. Regenerate Code

```bash
make graphql-generate
# or directly: gqlgen generate
```

This creates resolver stubs in the appropriate resolver files.

### 3. Implement Resolver

```go
func (r *patientResolver) ActiveOrders(ctx context.Context, obj *model.Patient) (int, error) {
    count, err := r.OrderService.CountActiveByPatientID(ctx, obj.ID)
    if err != nil {
        r.Logger.Error("Failed to count orders", zap.String("patient_id", obj.ID), zap.Error(err))
        return 0, err
    }
    return count, nil
}
```

### 4. Add Dependencies (if needed)

If you need a new service, add it to `internal/graphql/resolver.go`:

```go
type Resolver struct {
    PatientService      patientservice.PatientService
    OrderService        orderservice.OrderService  // NEW
    Logger              *zap.Logger
}
```

And wire it in `internal/app/wire.go`.

## Code Generation

We use [gqlgen](https://github.com/99designs/gqlgen) for code generation.

### Configuration (`gqlgen.yml`)

```yaml
schema:
  - internal/graphql/*.graphql
  - domain/*/graphql/*.graphql

exec:
  filename: internal/graphql/generated/generated.go
  package: generated

resolver:
  layout: follow-schema
  dir: internal/graphql
  package: graphql

autobind:
  - pharmacy-modernization-project-model/domain/patient/contracts/model
  - pharmacy-modernization-project-model/domain/prescription/contracts/model
  - pharmacy-modernization-project-model/domain/dashboard/contracts/model
```

### Autobind

The `autobind` configuration tells gqlgen to use existing domain models instead of generating new ones. This keeps GraphQL and domain models in sync.

## Testing GraphQL Queries

### Using GraphQL Playground

1. Start the server: `make dev`
2. Open browser: `http://localhost:8080/playground`
3. Write queries in left panel
4. Click play button
5. See results in right panel

### Using curl

```bash
curl -X POST http://localhost:8080/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ patients { id name } }"}'
```

### Using GraphQL Client Libraries

**JavaScript/TypeScript:**
```typescript
import { gql, GraphQLClient } from 'graphql-request'

const client = new GraphQLClient('http://localhost:8080/graphql')

const query = gql`
  query {
    patient(id: "123") {
      name
      prescriptions {
        drug
      }
    }
  }
`

const data = await client.request(query)
```

**Go:**
```go
import "github.com/machinebox/graphql"

client := graphql.NewClient("http://localhost:8080/graphql")

req := graphql.NewRequest(`
    query {
        patient(id: "123") {
            name
        }
    }
`)

var response struct {
    Patient struct {
        Name string
    }
}

client.Run(ctx, req, &response)
```

## Performance Considerations

### N+1 Queries

Currently, nested queries may result in N+1 queries:

```graphql
query {
  patients {          # 1 query
    prescriptions {   # N queries (one per patient)
      drug
    }
  }
}
```

**Solution (when needed):** Add DataLoader (see `docs/GRAPHQL_MIGRATION_PHASES.md` for details).

### Query Depth

Deep nesting can cause performance issues:

```graphql
query {
  patients {
    prescriptions {
      patient {
        prescriptions {
          patient {
            # ...infinite loop potential
          }
        }
      }
    }
  }
}
```

**Future Enhancement:** Add query depth limiting in production.

## Error Handling

Resolvers handle errors consistently:

```go
// Not Found → return nil (GraphQL null)
if errors.IsNotFoundError(err) {
    return nil, nil
}

// Other errors → return error (GraphQL error response)
return nil, err
```

### GraphQL Error Response

```json
{
  "data": {
    "patient": null
  },
  "errors": [
    {
      "message": "Failed to fetch patient",
      "path": ["patient"]
    }
  ]
}
```

## Middleware

GraphQL endpoint uses the same middleware as REST API:

- Request ID generation
- Correlation ID tracking
- Zap logging
- Panic recovery
- Request timeout (60s)

This is configured in `internal/app/wire.go` and applies to all routes.

## Security Considerations

### Current State (Development)

- ✅ Playground enabled for development
- ✅ All queries allowed
- ❌ No authentication
- ❌ No rate limiting
- ❌ No query complexity limits

### Production Recommendations

1. **Disable Playground**
   ```go
   // Only mount playground in development
   if a.Cfg.Environment != "production" {
       r.Handle("/playground", playground.Handler("GraphQL Playground", "/graphql"))
   }
   ```

2. **Add Authentication Middleware**
   ```go
   r.With(authMiddleware).Handle("/graphql", srv)
   ```

3. **Add Query Complexity Limits**
   ```go
   srv := handler.NewDefaultServer(generated.NewExecutableSchema(config))
   srv.Use(extension.FixedComplexityLimit(100))
   ```

4. **Add Rate Limiting**
   Use Chi middleware or custom rate limiter.

## Comparison: REST vs GraphQL

| Feature | REST API | GraphQL |
|---------|----------|---------|
| **Endpoint** | Multiple (`/api/patients`, `/api/prescriptions`) | Single (`/graphql`) |
| **Data Fetching** | Fixed response per endpoint | Client specifies fields |
| **Over-fetching** | Common (get all fields) | Rare (request only needed) |
| **Under-fetching** | Common (multiple requests) | Rare (single request) |
| **Versioning** | URL versioning (`/v1/`, `/v2/`) | Schema evolution (deprecation) |
| **Caching** | HTTP caching works well | Requires custom caching |
| **Learning Curve** | Low | Medium |

### When to Use Each

**Use REST when:**
- Simple CRUD operations
- Standard HTTP caching needed
- Team unfamiliar with GraphQL
- Public API (easier to document)

**Use GraphQL when:**
- Complex nested data relationships
- Mobile apps (reduce network calls)
- Flexible client requirements
- Rapidly evolving UI needs

## Next Steps

See `docs/GRAPHQL_MIGRATION_PHASES.md` for information about:

- **Phase 2**: Internal subgraphs (federation prep)
- **Phase 3**: Extract first service
- **Phase 4**: Full federation
- **Advanced**: DataLoader, Apollo GraphOS, Service Mesh

---

## Troubleshooting

### Build Errors After Schema Changes

```bash
# Regenerate code
make graphql-generate

# Clean and rebuild
rm -rf internal/graphql/generated
make graphql-generate
go mod tidy
go build ./cmd/server
```

### gqlgen Not Found

```bash
# Install gqlgen
make graphql-install

# Then regenerate
make graphql-generate
```

### Resolver Not Implementing Interface

Check `internal/graphql/generated/generated.go` for the expected signature, then update your resolver in `schema.resolvers.go`.

### Type Mismatch Errors

Ensure domain models match GraphQL types, or add conversion logic in resolvers.

---

## References

- [gqlgen Documentation](https://gqlgen.com/)
- [GraphQL Best Practices](https://graphql.org/learn/best-practices/)
- [GraphQL Playground](https://github.com/graphql/graphql-playground)
- [GraphQL Spec](https://spec.graphql.org/)

