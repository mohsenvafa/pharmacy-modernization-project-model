# Component Implementation Guide

Complete guide for implementing UI components in the RxIntake application.

## üìã Table of Contents

1. [Component Types](#component-types)
2. [File Structure](#file-structure)
3. [Component Anatomy](#component-anatomy)
4. [Implementation Patterns](#implementation-patterns)
5. [Coding Conventions](#coding-conventions)
6. [Examples](#examples)
7. [Best Practices](#best-practices)

---

## üéØ Component Types

The application uses three distinct component types, each serving different purposes:

### 1. **Page Components** (HTTP Request Rendered)
- **Purpose**: Full page components rendered on HTTP request
- **Characteristics**:
  - Have HTTP handlers (`Handler(w http.ResponseWriter, r *http.Request)`)
  - Wrap content in `BaseLayout`
  - Registered as routes in `ui.go`
  - Executed server-side on each request
  - First content user sees

**Use Cases**:
- List pages (e.g., patient list)
- Detail pages (e.g., patient profile)
- Form pages (e.g., create/edit pages)
- Search pages

**Location**: `domain/{domain}/ui/{page_name}/`

**Example**: `domain/patient/ui/patient_list/`

---

### 2. **Eager Components** (Server-Side Rendered)
- **Purpose**: Sub-components rendered server-side with parent page
- **Characteristics**:
  - Return `templ.Component`
  - Have `View()` method instead of `Handler()`
  - Rendered immediately with page load
  - No separate HTTP request
  - Data fetched during parent render

**Use Cases**:
- Address lists
- User profiles
- Static data displays
- Always-visible sections

**Location**: `domain/{domain}/ui/components/{component_name}/`

**Example**: `domain/patient/ui/components/address_list/`

---

### 3. **Lazy Components** (HTMX Loaded)
- **Purpose**: Components loaded on-demand via HTMX
- **Characteristics**:
  - Have HTTP handlers for separate endpoint
  - Use `hx-get`, `hx-trigger="revealed once"`
  - Placeholder templ with skeleton
  - Loaded when visible or triggered
  - Improves initial page load performance

**Use Cases**:
- Below-the-fold content
- Heavy/slow data queries
- Conditionally displayed sections
- Performance-critical pages

**Location**: `domain/{domain}/ui/components/{component_name}/`

**Example**: `domain/patient/ui/components/patient_prescriptions/`

---

## üìÅ File Structure

Every component follows a consistent file structure:

```
component_name/
‚îú‚îÄ‚îÄ component_name.component.templ     # HTML template (required)
‚îú‚îÄ‚îÄ component_name.component.go        # Backend logic (required)
‚îú‚îÄ‚îÄ component_name.component.ts        # Client-side logic (optional)
‚îî‚îÄ‚îÄ component_name.component_templ.go  # Generated (auto-generated by templ)
```

### File Naming Conventions

| File Type | Pattern | Example |
|-----------|---------|---------|
| Template | `{name}.component.templ` | `patient_list.component.templ` |
| Go Backend | `{name}.component.go` | `patient_list.component.go` |
| TypeScript | `{name}.component.ts` | `patient_list.component.ts` |
| Generated | `{name}.component_templ.go` | Auto-generated |

**‚ö†Ô∏è Important**: 
- Use **snake_case** for folder and file names
- Use **PascalCase** for Go struct names
- Use **PascalCase** for TypeScript class names

---

## üèóÔ∏è Component Anatomy

### 1. Templ File (`.component.templ`)

**Purpose**: Contains only HTML markup, no business logic

```go
package component_name

import (
	"pharmacy-modernization-project-model/domain/patient/contracts/model"
	layouts "pharmacy-modernization-project-model/web/components/layouts"
	components "pharmacy-modernization-project-model/web/components/elements"
)

// Parameter struct for the component
type ComponentNameParams struct {
	Title   string
	Data    []model.SomeModel
	Config  SomeConfig
}

// Main templ definition
templ ComponentNameView(params ComponentNameParams) {
	<div class="component-container" data-component="domain.component-name">
		<h2>{ params.Title }</h2>
		if len(params.Data) == 0 {
			<p>No data available</p>
		} else {
			for _, item := range params.Data {
				<div>{ item.Name }</div>
			}
		}
	</div>
}

// For lazy components: Placeholder templ
templ PlaceHolder(id string) {
	<div
		id={ "component-" + id }
		hx-get={ "/path/to/component?id=" + id }
		hx-trigger="revealed once"
		hx-swap="outerHTML"
		hx-target="this"
		class="card skeleton"
	>
		<div class="spinner p-4">Loading...</div>
	</div>
}
```

**Templ File Rules**:
- ‚úÖ **DO**: Keep only HTML structure
- ‚úÖ **DO**: Use Go expressions for logic (`if`, `for`, etc.)
- ‚úÖ **DO**: Accept parameters via struct
- ‚úÖ **DO**: Add `data-component` attribute for TypeScript targeting
- ‚ùå **DON'T**: Make service calls
- ‚ùå **DON'T**: Perform complex calculations
- ‚ùå **DON'T**: Access database directly

---

### 2. Go File (`.component.go`)

**Purpose**: Business logic, data fetching, and rendering

#### Page Component (HTTP Handler)

```go
package component_name

import (
	"net/http"
	"github.com/go-chi/chi/v5"
	"go.uber.org/zap"
	
	service "pharmacy-modernization-project-model/domain/patient/service"
	contracts "pharmacy-modernization-project-model/domain/patient/ui/contracts"
)

type ComponentNameComponent struct {
	service service.SomeService
	log     *zap.Logger
}

// Constructor - receives dependencies
func NewComponentNameComponent(deps *contracts.UiDependencies) *ComponentNameComponent {
	return &ComponentNameComponent{
		service: deps.SomeService,
		log:     deps.Log,
	}
}

// Handler - HTTP request handler
func (c *ComponentNameComponent) Handler(w http.ResponseWriter, r *http.Request) {
	// 1. Extract parameters
	id := chi.URLParam(r, "id")
	if id == "" {
		http.Error(w, "missing id", http.StatusBadRequest)
		return
	}
	
	// 2. Fetch data
	data, err := c.service.GetByID(r.Context(), id)
	if err != nil {
		c.log.Error("failed to fetch data", zap.Error(err))
		http.Error(w, "failed to load data", http.StatusInternalServerError)
		return
	}
	
	// 3. Prepare view parameters
	params := ComponentNameParams{
		Title: "My Component",
		Data:  data,
	}
	
	// 4. Render view
	view := ComponentNameView(params)
	if err := view.Render(r.Context(), w); err != nil {
		c.log.Error("failed to render", zap.Error(err))
		http.Error(w, "failed to render", http.StatusInternalServerError)
		return
	}
}
```

#### Eager Component (Returns templ.Component)

```go
package component_name

import (
	"context"
	"errors"
	
	"github.com/a-h/templ"
	"go.uber.org/zap"
	
	service "pharmacy-modernization-project-model/domain/patient/service"
	contracts "pharmacy-modernization-project-model/domain/patient/ui/contracts"
)

type ComponentNameComponent struct {
	service service.SomeService
	log     *zap.Logger
}

// Constructor
func NewComponentNameComponent(deps *contracts.UiDependencies) *ComponentNameComponent {
	return &ComponentNameComponent{
		service: deps.SomeService,
		log:     deps.Log,
	}
}

// View - returns templ.Component for embedding in parent
func (c *ComponentNameComponent) View(ctx context.Context, id string) (templ.Component, error) {
	// 1. Validate input
	if id == "" {
		return nil, errors.New("id is required")
	}
	
	// 2. Fetch data
	data, err := c.service.GetByID(ctx, id)
	if err != nil {
		c.log.Error("failed to load data", zap.Error(err), zap.String("id", id))
		return nil, err
	}
	
	// 3. Return component
	return ComponentNameView(ComponentNameParams{
		Title: "My Component",
		Data:  data,
	}), nil
}
```

#### Lazy Component (HTTP Handler + Placeholder)

```go
package component_name

import (
	"context"
	"errors"
	"net/http"
	
	"github.com/a-h/templ"
	"go.uber.org/zap"
	
	service "pharmacy-modernization-project-model/domain/patient/service"
	contracts "pharmacy-modernization-project-model/domain/patient/ui/contracts"
)

type ComponentNameComponent struct {
	service service.SomeService
	log     *zap.Logger
}

// Constructor
func NewComponentNameComponent(deps *contracts.UiDependencies) *ComponentNameComponent {
	return &ComponentNameComponent{
		service: deps.SomeService,
		log:     deps.Log,
	}
}

// Handler - for HTMX lazy loading
func (c *ComponentNameComponent) Handler(w http.ResponseWriter, r *http.Request) {
	id := r.URL.Query().Get("id")
	
	view, err := c.componentView(r.Context(), id)
	if err != nil {
		http.Error(w, "failed to load component", http.StatusInternalServerError)
		return
	}
	
	// Render the component
	if err := view.Render(r.Context(), w); err != nil {
		http.Error(w, "failed to render", http.StatusInternalServerError)
	}
}

// componentView - private method for data fetching
func (c *ComponentNameComponent) componentView(ctx context.Context, id string) (templ.Component, error) {
	if id == "" {
		return nil, errors.New("id is required")
	}
	
	data, err := c.service.GetByID(ctx, id)
	if err != nil {
		c.log.Error("failed to load data", zap.Error(err), zap.String("id", id))
		return nil, err
	}
	
	return ComponentNameView(ComponentNameParams{
		Title: "My Component",
		Data:  data,
	}), nil
}
```

**Go File Rules**:
- ‚úÖ **DO**: Keep constructor name pattern: `New{ComponentName}Component`
- ‚úÖ **DO**: Accept `*contracts.UiDependencies` in constructor
- ‚úÖ **DO**: Use context for all service calls
- ‚úÖ **DO**: Log errors with structured logging
- ‚úÖ **DO**: Return proper HTTP status codes
- ‚úÖ **DO**: Validate all inputs
- ‚ùå **DON'T**: Put business logic here (use services)
- ‚ùå **DON'T**: Access database directly

---

### 3. TypeScript File (`.component.ts`) - Optional

**Purpose**: Client-side interactivity and behavior

```typescript
/**
 * ComponentName Component
 * Brief description of component functionality
 */

export class ComponentNameComponent {
  private element: HTMLElement
  
  constructor(element: HTMLElement) {
    this.element = element
    this.init()
  }
  
  private init(): void {
    // Set up event listeners
    this.setupEventListeners()
    
    // Initialize component state
    this.loadData()
  }
  
  private setupEventListeners(): void {
    const button = this.element.querySelector('.action-button')
    button?.addEventListener('click', this.handleClick.bind(this))
  }
  
  private handleClick(event: Event): void {
    event.preventDefault()
    // Handle click logic
  }
  
  private async loadData(): Promise<void> {
    try {
      const response = await fetch('/api/data')
      const data = await response.json()
      this.render(data)
    } catch (error) {
      console.error('Failed to load data:', error)
    }
  }
  
  private render(data: any): void {
    // Update DOM
  }
  
  // Public method for cleanup
  public destroy(): void {
    // Remove event listeners
    // Clean up resources
  }
}
```

**TypeScript File Rules**:
- ‚úÖ **DO**: Use PascalCase for class names
- ‚úÖ **DO**: Keep class name pattern: `{ComponentName}Component`
- ‚úÖ **DO**: Accept element in constructor
- ‚úÖ **DO**: Use `private` for internal methods
- ‚úÖ **DO**: Implement `destroy()` for cleanup
- ‚úÖ **DO**: Use async/await for API calls
- ‚úÖ **DO**: Handle errors gracefully
- ‚ùå **DON'T**: Manipulate DOM outside component element
- ‚ùå **DON'T**: Use global variables

**Registering TypeScript Components**:

In `domain/{domain}/ui/ts/register_components.ts`:

```typescript
import { ComponentNameComponent } from '../component_name/component_name.component'

export function registerDomainComponents(): void {
  document.addEventListener('DOMContentLoaded', () => {
    const elements = document.querySelectorAll('[data-component="domain.component-name"]')
    elements.forEach(el => new ComponentNameComponent(el as HTMLElement))
  })
}
```

---

## üîÑ Implementation Patterns

### Pattern 1: Page Component with Eager Sub-Components

**Use Case**: Detail page with always-visible sections

```go
// Page Component (patient_detail/patient_detail_page.component.go)
func (h *PatientDetailComponent) Handler(w http.ResponseWriter, r *http.Request) {
	patientID := chi.URLParam(r, "patientID")
	
	// Fetch main data
	patient, err := h.patientsService.GetByID(r.Context(), patientID)
	if err != nil {
		http.Error(w, "failed to load patient", http.StatusInternalServerError)
		return
	}
	
	// Render eager sub-component
	var addressComponent templ.Component
	if h.addressListComponent != nil {
		component, err := h.addressListComponent.View(r.Context(), patientID)
		if err != nil {
			http.Error(w, "failed to load addresses", http.StatusInternalServerError)
			return
		}
		addressComponent = component
	}
	
	// Render page with sub-component
	view := PatientDetailPageComponentView(PatientDetailPageParam{
		Patient:     patient,
		AddressList: addressComponent,
	})
	
	view.Render(r.Context(), w)
}
```

### Pattern 2: Page Component with Lazy Sub-Components

**Use Case**: Detail page with below-the-fold heavy content

```go
// Page Component (patient_detail/patient_detail_page.component.go)
func (h *PatientDetailComponent) Handler(w http.ResponseWriter, r *http.Request) {
	patientID := chi.URLParam(r, "patientID")
	
	// Fetch main data only
	patient, err := h.patientsService.GetByID(r.Context(), patientID)
	if err != nil {
		http.Error(w, "failed to load patient", http.StatusInternalServerError)
		return
	}
	
	// Use placeholder for lazy component
	var prescriptionComponent templ.Component
	if h.prescriptionListComponent != nil {
		prescriptionComponent = patientprescriptions.PlaceHolder(patientID)
	}
	
	// Render page with placeholder
	view := PatientDetailPageComponentView(PatientDetailPageParam{
		Patient:       patient,
		Prescriptions: prescriptionComponent,
	})
	
	view.Render(r.Context(), w)
}
```

```templ
// Placeholder templ (patient_prescriptions/patient_prescription_list.templ)
templ PlaceHolder(patientID string) {
	<div
		id={ "patient-prescriptionscard-" + patientID }
		hx-get={ "/patients/components/patient-prescriptions-card?patientId=" + patientID }
		hx-trigger="revealed once"
		hx-swap="outerHTML"
		hx-target="this"
		hx-select="section.card"
		hx-indicator={ "#loading-" + patientID }
		class="card skeleton"
	>
		<div id={ "loading-" + patientID } class="spinner p-4">Loading Prescriptions‚Ä¶</div>
	</div>
}
```

### Pattern 3: List Component with Pagination

```go
func (c *PatientListComponent) Handler(w http.ResponseWriter, r *http.Request) {
	// Get page number from query params
	pageParam := r.URL.Query().Get("page")
	pageNum, err := strconv.Atoi(pageParam)
	if err != nil {
		pageNum = 1
	}
	
	// Fetch all data (or use database pagination)
	patients, err := c.patientsService.List(r.Context(), "", 1000, 0)
	if err != nil {
		http.Error(w, "failed to load patients", http.StatusInternalServerError)
		return
	}
	
	// Paginate in memory
	patientsPage, totalPages, currentPage := paginatePatients(patients, pageNum)
	
	// Render with pagination
	view := PatientListPageComponentView(PatientListPageParam{
		Patients:    patientsPage,
		CurrentPage: currentPage,
		TotalPages:  totalPages,
		ListPath:    paths.PatientListURL(),
	})
	
	view.Render(r.Context(), w)
}
```

---

## üìù Coding Conventions

### Naming Conventions

| Element | Convention | Example |
|---------|-----------|---------|
| Folder name | snake_case | `patient_list` |
| File name | snake_case | `patient_list.component.go` |
| Go struct | PascalCase | `PatientListComponent` |
| Go method | PascalCase | `Handler()`, `View()` |
| Go function | PascalCase | `NewPatientListComponent()` |
| Templ function | PascalCase | `PatientListView()` |
| TypeScript class | PascalCase | `PatientListComponent` |
| CSS class | kebab-case | `patient-list` |
| data-component | domain.kebab-case | `patient.patient-list` |

### Package Naming

```go
// Page components
package patient_list        // folder: patient_list/

// Sub-components
package addresslist          // folder: address_list/
package patientprescriptions // folder: patient_prescriptions/
```

**Rules**:
- Package name should match folder name (without underscores)
- Use descriptive, domain-specific names
- Avoid generic names like `component` or `view`

### Import Organization

```go
import (
	// Standard library
	"context"
	"errors"
	"net/http"
	
	// Third-party libraries
	"github.com/a-h/templ"
	"github.com/go-chi/chi/v5"
	"go.uber.org/zap"
	
	// Project imports - domain
	service "pharmacy-modernization-project-model/domain/patient/service"
	model "pharmacy-modernization-project-model/domain/patient/contracts/model"
	
	// Project imports - UI
	contracts "pharmacy-modernization-project-model/domain/patient/ui/contracts"
	paths "pharmacy-modernization-project-model/domain/patient/ui/paths"
	
	// Project imports - shared
	components "pharmacy-modernization-project-model/web/components/elements"
	layouts "pharmacy-modernization-project-model/web/components/layouts"
)
```

### Error Handling

**Pattern**:
```go
// 1. Check error
data, err := c.service.GetByID(ctx, id)
if err != nil {
	// 2. Log with context
	c.log.Error("failed to fetch data", 
		zap.Error(err), 
		zap.String("id", id),
		zap.String("operation", "GetByID"),
	)
	// 3. Return user-friendly message
	http.Error(w, "failed to load data", http.StatusInternalServerError)
	return
}
```

**Rules**:
- Always log errors with context
- Return user-friendly messages
- Use appropriate HTTP status codes
- Never expose internal errors to users

### HTTP Status Codes

| Code | When to Use |
|------|-------------|
| 200 OK | Successful response |
| 400 Bad Request | Invalid input (missing params, validation) |
| 404 Not Found | Resource doesn't exist |
| 500 Internal Server Error | Server/service errors |
| 503 Service Unavailable | External service down |

### Logging

**Pattern**:
```go
// Info logs
c.log.Info("operation completed", 
	zap.String("operation", "GetByID"),
	zap.String("id", id),
	zap.Duration("duration", time.Since(start)),
)

// Error logs
c.log.Error("operation failed", 
	zap.Error(err),
	zap.String("operation", "GetByID"),
	zap.String("id", id),
	zap.Any("context", ctx),
)

// Debug logs (development only)
c.log.Debug("processing request", 
	zap.String("path", r.URL.Path),
	zap.Any("params", params),
)
```

### Context Handling

**Always use context**:
```go
// ‚úÖ Good
data, err := c.service.GetByID(ctx, id)

// ‚ùå Bad
data, err := c.service.GetByID(id)
```

**Context rules**:
- Always accept `context.Context` as first parameter
- Pass context to all service calls
- Use `r.Context()` from HTTP requests
- Never create background context in handlers

---

## üìñ Examples

### Complete Example: Eager Component

**File**: `domain/patient/ui/components/address_list/address_list.component.templ`
```go
package addresslist

import addressmodel "pharmacy-modernization-project-model/domain/patient/contracts/model"

type AddressListParams struct {
	Title        string
	EmptyMessage string
	Addresses    []addressmodel.Address
}

templ AddressListComponentView(params AddressListParams) {
	<section class="card bg-base-100 shadow" data-component="patient.address-list">
		<div class="card-body space-y-4">
			<div>
				<h2 class="card-title">{ params.Title }</h2>
				<p class="text-sm opacity-60">Patient mailing addresses.</p>
			</div>
			if len(params.Addresses) == 0 {
				<div class="rounded-lg bg-base-200/60 p-4 text-sm opacity-70">
					{ params.EmptyMessage }
				</div>
			} else {
				<ul class="space-y-3">
					for _, address := range params.Addresses {
						<li class="rounded-lg border border-base-300 p-4">
							<p class="font-semibold">{ address.Line1 }</p>
							if address.Line2 != "" {
								<p class="text-sm">{ address.Line2 }</p>
							}
							<p class="text-sm opacity-70">
								{ address.City }, { address.State } { address.Zip }
							</p>
						</li>
					}
				</ul>
			}
		</div>
	</section>
}
```

**File**: `domain/patient/ui/components/address_list/address_list.component.go`
```go
package addresslist

import (
	"context"
	"errors"
	
	"github.com/a-h/templ"
	"go.uber.org/zap"
	
	patSvc "pharmacy-modernization-project-model/domain/patient/service"
	contracts "pharmacy-modernization-project-model/domain/patient/ui/contracts"
)

type AddressListComponent struct {
	service patSvc.AddressService
	log     *zap.Logger
}

func NewAddressListComponent(deps *contracts.UiDependencies) *AddressListComponent {
	return &AddressListComponent{service: deps.AddressSvc, log: deps.Log}
}

func (c *AddressListComponent) View(ctx context.Context, patientID string) (templ.Component, error) {
	if patientID == "" {
		return nil, errors.New("patient id is required")
	}
	
	addresses, err := c.service.GetByPatientID(ctx, patientID)
	if err != nil {
		if c.log != nil {
			c.log.Error("failed to load patient addresses", zap.Error(err), zap.String("patient_id", patientID))
		}
		return nil, err
	}
	
	return AddressListComponentView(AddressListParams{
		Title:        "Addresses",
		EmptyMessage: "No addresses on file for this patient.",
		Addresses:    addresses,
	}), nil
}
```

**File**: `domain/patient/ui/components/address_list/address_list.component.ts`
```typescript
/**
 * Address List Component
 * Handles address list interactions
 */

export class AddressListComponent {
  constructor() {
    this.init()
  }
  
  private init(): void {
    console.log('Address List component initialized')
  }
}
```

### Complete Example: Lazy Component

**File**: `domain/patient/ui/components/patient_prescriptions/patient_prescription_list.templ`
```go
package patientprescriptions

import (
	commonmodel "pharmacy-modernization-project-model/domain/common/model"
	helper "pharmacy-modernization-project-model/internal/helper"
)

type PrescriptionListParams struct {
	Title         string
	EmptyMessage  string
	Prescriptions []commonmodel.PatientPrescription
}

templ PrescriptionListComponentView(params PrescriptionListParams) {
	<section class="card bg-base-100 shadow" data-component="patient.patient-prescriptions">
		<div class="card-body space-y-4">
			<div>
				<h2 class="card-title">{ params.Title }</h2>
				<p class="text-sm opacity-60">Current prescriptions for this patient.</p>
			</div>
			if len(params.Prescriptions) == 0 {
				<div class="rounded-lg bg-base-200/60 p-4 text-sm opacity-70">
					{ params.EmptyMessage }
				</div>
			} else {
				<div class="overflow-x-auto">
					<table class="table">
						<thead>
							<tr>
								<th>ID</th>
								<th>Drug</th>
								<th>Status</th>
							</tr>
						</thead>
						<tbody>
							for _, rx := range params.Prescriptions {
								<tr>
									<td>{ rx.ID }</td>
									<td>{ rx.Drug }</td>
									<td>
										<span class="badge">{ rx.Status }</span>
									</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			}
		</div>
	</section>
}

templ PlaceHolder(patientID string) {
	<div
		id={ "patient-prescriptionscard-" + patientID }
		hx-get={ "/patients/components/patient-prescriptions-card?patientId=" + patientID }
		hx-trigger="revealed once"
		hx-swap="outerHTML"
		hx-target="this"
		class="card skeleton"
	>
		<div class="spinner p-4">Loading Prescriptions‚Ä¶</div>
	</div>
}
```

**File**: `domain/patient/ui/components/patient_prescriptions/patient_prescription_list.component.go`
```go
package patientprescriptions

import (
	"context"
	"errors"
	"net/http"
	
	"github.com/a-h/templ"
	"go.uber.org/zap"
	
	patientproviders "pharmacy-modernization-project-model/domain/patient/providers"
	contracts "pharmacy-modernization-project-model/domain/patient/ui/contracts"
)

type PrescriptionListComponent struct {
	provider patientproviders.PatientPrescriptionProvider
	log      *zap.Logger
}

func NewPrescriptionListComponent(deps *contracts.UiDependencies) *PrescriptionListComponent {
	return &PrescriptionListComponent{provider: deps.PrescriptionProvider, log: deps.Log}
}

func (h *PrescriptionListComponent) Handler(w http.ResponseWriter, r *http.Request) {
	patientID := r.URL.Query().Get("patientId")
	view, err := h.componentView(r.Context(), patientID)
	if err != nil {
		http.Error(w, "failed to load patient prescriptions", http.StatusInternalServerError)
		return
	}
	
	if err := view.Render(r.Context(), w); err != nil {
		http.Error(w, "failed to render patient prescriptions", http.StatusInternalServerError)
	}
}

func (h *PrescriptionListComponent) componentView(ctx context.Context, patientID string) (templ.Component, error) {
	if patientID == "" {
		return nil, errors.New("patient id is required")
	}
	
	prescriptions, err := h.provider.PatientPrescriptionListByPatientID(ctx, patientID)
	if err != nil {
		h.log.Error("failed to load prescriptions", zap.Error(err), zap.String("patient_id", patientID))
		return nil, err
	}
	
	return PrescriptionListComponentView(PrescriptionListParams{
		Title:         "Prescriptions",
		EmptyMessage:  "No prescriptions found for this patient.",
		Prescriptions: prescriptions,
	}), nil
}
```

---

## ‚úÖ Best Practices

### 1. Component Responsibility
- **Single Responsibility**: Each component should do one thing
- **No Business Logic**: Keep business logic in services
- **No Direct DB Access**: Always use services/repositories

### 2. Performance
- **Use Lazy Loading**: For below-the-fold or heavy content
- **Minimize Data**: Only fetch what's needed
- **Pagination**: For large lists
- **Caching**: Consider caching where appropriate

### 3. Error Handling
- **Always Log Errors**: With structured logging
- **User-Friendly Messages**: Don't expose internals
- **Proper Status Codes**: Use correct HTTP codes
- **Graceful Degradation**: Show empty states, not errors

### 4. Accessibility
- **Semantic HTML**: Use proper HTML elements
- **ARIA Labels**: For interactive elements
- **Keyboard Navigation**: Ensure keyboard accessibility
- **Loading States**: Show spinners/skeletons

### 5. Testing
- **Unit Tests**: Test component logic
- **Integration Tests**: Test with real services
- **E2E Tests**: Test user flows

### 6. Documentation
- **Component Purpose**: Document what it does
- **Parameters**: Document required parameters
- **Dependencies**: Document service dependencies
- **Examples**: Provide usage examples

---

## üîó Related Documentation

- [Architecture Overview](./ARCHITECTURE.md)
- [Security Implementation](../security/SECURITY_ARCHITECTURE.md)
- [TypeScript Components](../typescript/ADDING_TYPESCRIPT_COMPONENTS.md)
- [GraphQL Implementation](../graphql/GRAPHQL_IMPLEMENTATION.md)

---

## üÜò Troubleshooting

### Common Issues

**Issue**: Component not rendering
- Check if templ file is compiled (`templ generate`)
- Verify component is registered in `ui.go`
- Check for errors in browser console

**Issue**: HTMX not loading component
- Verify `hx-get` URL is correct
- Check network tab for failed requests
- Ensure handler is registered

**Issue**: TypeScript not working
- Run `npm run build`
- Check `data-component` attribute matches selector
- Verify component is registered in `register_components.ts`

---

**Last Updated**: October 7, 2025
**Version**: 1.0

